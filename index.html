<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>DFS回溯展示-大击败</title>
<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
body {
  font-family: Arial;
  display: flex;
  gap: 20px;
}

svg {
  border: 1px solid #ccc;
}

.node circle {
  fill: lightblue;
  stroke: #333;
  stroke-width: 1.5px;
}

.node text {
  font-size: 12px;
  pointer-events: none;
}

.link {
  stroke: #999;
  stroke-width: 2px;
}

.active {
  fill: orange;
}

.highlight {
  stroke: orange;
  stroke-width: 4px;
}

.panel {
  width: 300px;
}
</style>
</head>

<body>

<svg width="500" height="400"></svg>

<div class="panel">
  <button onclick="nextStep()">Next Step</button>

  <p><b>当前操作：</b><span id="action"></span></p>
  <p><b>当前路径：</b><span id="path"></span></p>

  <p><b>visited[] 状态：</b></p>
  <ul id="visitedPanel"></ul>

  <p><b>已找到路径：</b></p>
  <ul id="results"></ul>
</div>

<script>
// ========================
// 1. 节点（固定位置）
// ========================
const nodes = [
  {id:0, x:300, y:40},

  {id:1, x:160, y:120},
  {id:2, x:440, y:120},

  {id:3, x:110, y:240},
  {id:4, x:210, y:240},

  {id:5, x:390, y:240},
  {id:6, x:490, y:240},

  {id:7, x:300, y:360}
];

// ========================
// 2. 边（无向）
// ========================
const links = [
  {source:0, target:1},
  {source:0, target:2},

  {source:1, target:3},
  {source:1, target:4},

  {source:2, target:5},
  {source:2, target:6},

  {source:3, target:7},
  {source:4, target:7},
  {source:4, target:5},
  {source:5, target:7},
  {source:6, target:7}
];

// ========================
// 3. 邻接表
// ========================
const adj = {};
nodes.forEach(n => adj[n.id] = []);
links.forEach(l => {
  adj[l.source].push(l.target);
  adj[l.target].push(l.source);
});

// ========================
// 4. 画图（不用 force）
// ========================
const svg = d3.select("svg");

const link = svg.selectAll(".link")
  .data(links)
  .enter()
  .append("line")
  .attr("class", "link")
  .attr("x1", d => nodes[d.source].x)
  .attr("y1", d => nodes[d.source].y)
  .attr("x2", d => nodes[d.target].x)
  .attr("y2", d => nodes[d.target].y);

const node = svg.selectAll(".node")
  .data(nodes)
  .enter()
  .append("g")
  .attr("class", "node")
  .attr("transform", d => `translate(${d.x},${d.y})`);

node.append("circle").attr("r", 15);
node.append("text")
  .attr("dx", -5)
  .attr("dy", 5)
  .text(d => d.id);

// ========================
// 5. DFS 生成“步骤”
// ========================
let steps = [];

function dfs(u, target, visited, path) {
  // 进入节点
  steps.push({
    type: "enter",
    node: u,
    path: [...path, u],
    visited: new Set(visited)
  });

  visited.add(u);
  path.push(u);

  if (u === target) {
    // 找到一条路径
    steps.push({
      type: "found",
      path: [...path],
      visited: new Set(visited)
    });
  } else {
    for (let v of adj[u]) {
      if (!visited.has(v)) {
        dfs(v, target, visited, path);
      }
    }
  }

  // 回溯
  steps.push({
    type: "exit",
    node: u,
    path: [...path],
    visited: new Set(visited)
  });

  path.pop();
  visited.delete(u);
}

// 起点 0，终点 7
dfs(0, 7, new Set(), []);

// ========================
// 6. visited[] 显示函数
// ========================
function renderVisited(visitedSet) {
  const panel = document.getElementById("visitedPanel");
  panel.innerHTML = "";

  nodes.forEach(n => {
    const li = document.createElement("li");
    li.innerText = n.id + " : " + (visitedSet.has(n.id) ? "✓" : "✗");
    panel.appendChild(li);
  });
}

// ========================
// 7. 一步一步执行
// ========================
let idx = 0;

function nextStep() {
  if (idx >= steps.length) return;

  const s = steps[idx++];

  node.select("circle").classed("active", false);
  link.classed("highlight", false);

  document.getElementById("path").innerText =
    s.path.join(" → ");

  renderVisited(s.visited);

  if (s.type === "enter")
    document.getElementById("action").innerText =
      "进入节点 " + s.node;

  if (s.type === "exit")
    document.getElementById("action").innerText =
      "从节点 " + s.node + " 回溯";

  if (s.type === "found") {
    document.getElementById("action").innerText =
      "找到一条路径";
    const li = document.createElement("li");
    li.innerText = s.path.join(" → ");
    document.getElementById("results").appendChild(li);
  }

  // 高亮当前路径
  s.path.forEach((n, i) => {
    node.filter(d => d.id === n)
      .select("circle")
      .classed("active", true);

    if (i < s.path.length - 1) {
      link.filter(d =>
        (d.source === s.path[i] && d.target === s.path[i + 1]) ||
        (d.source === s.path[i + 1] && d.target === s.path[i])
      ).classed("highlight", true);
    }
  });
}
</script>

</body>
</html>

